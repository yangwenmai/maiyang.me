---
layout: post
title: 'Gitlab-CI深入分析及基于Golang的CI实战'
keywords: gitlab, gitlab-ci,gitlab-runner,golang
date: 2017-06-08 22:50
description: 'gitlab-ci深入分析及实战'
categories: [gitlab]
tags: [gitlab,ci,golang,gitlab-runner]
comments: true
group: archive
icon: file-o
---

	本文耗时120分钟，阅读需要15分钟。

----

今天要给大家分享的是gitlab做持续集成。

大家是不是很羡慕Github上的这些图标啊？

[![Build Status](https://travis-ci.org/pingcap/tidb.svg?branch=master)](https://travis-ci.org/pingcap/tidb)
[![Go Report Card](https://goreportcard.com/badge/github.com/pingcap/tidb)](https://goreportcard.com/report/github.com/pingcap/tidb)
![Project Status](https://img.shields.io/badge/status-rc-yellow.svg)
[![CircleCI Status](https://circleci.com/gh/pingcap/tidb.svg?style=shield)](https://circleci.com/gh/pingcap/tidb)
[![Coverage Status](https://coveralls.io/repos/github/pingcap/tidb/badge.svg?branch=master)](https://coveralls.io/github/pingcap/tidb?branch=master)

反正我看到他们是很舒服的。

一般来说公司都不会采用GitHub去托管，一般都是用gitlab自建的，

### 我们为什么需要持续集成？

大多数的程序员都会说自己没有时间写测试用例，但他们又花了大量的时间在进行手动测试，修复bug，再手动测试。

如果我们写好测试用例，每次提交代码后都自动进行编译，然后将这些测试用例全部跑一遍，如果测试失败能够获取到足够的反馈信息，这样避免了重复构建测试环境、手动运行测试用例等低效率的工作，这就是持续集成的好处。

而且还有直观报告，多好啊。

持续集成，业界最流行，最成熟的应该要属Jenkins了。

但是我们今天要说的不是它，而是Gitlab自带的ci。

### 先来看看一些名词解释
#### Gitlab-CI

Gitlab-CI是GitLab Continuous Integration（Gitlab持续集成）的简称。
从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。
只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。

#### Gitlab-runner

Gitlab-runner是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和Gitlab安装在同一台机器上，但是考虑到GitLab Runner的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。

#### Pipelines

Pipelines是定义于.gitlab-ci.yml中的不同阶段的不同任务。
我把Pipelines理解为流水线，流水线包含有多个阶段（stages），每个阶段包含有一个或多个工序（jobs），比如先购料、组装、测试、包装再上线销售，每一次push或者MR都要经过流水线之后才可以合格出厂。而.gitlab-ci.yml正是定义了这条流水线有哪些阶段，每个阶段要做什么事。

#### Badges

徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。

徽章的链接形如：
http://example.gitlab.com/namespace/project/badges/branch/build.svg 

### 安装配置

**安装Gitlab**

安装 docker 环境，centos 的话可以使用 `sudo yum install -y docker` 直接安装，然后启动 docker，`sudo service docker start`。

**下载相关docker镜像**

gitlab/gitlab-ce:latest （gitlab 的 docker镜像）
gitlab/gitlab-runner:latest （用于持续集成，构建测试环境）
golang:1.8.3 （golang基础环境，用于编译代码，运行测试用例）

**启动 gitlab**

可以参考官方文档:[http://doc.gitlab.com/omnibus/docker/README.html](http://doc.gitlab.com/omnibus/docker/README.html)

启动 gitlab 就是启动相应的 docker 镜像，设置好相关配置参数，命令如下：

```shell
sudo docker run --detach \
    --hostname x.x.x.x \
    --publish 7000:443 --publish 80:80 --publish 7002:22 \
    --name gitlab \
    --restart always \
    --volume /srv/gitlab/config:/etc/gitlab \
    --volume /srv/gitlab/logs:/var/log/gitlab \
    --volume /srv/gitlab/data:/var/opt/gitlab \
    gitlab/gitlab-ce:latest
```

`hostname` 可以是gitlab服务器的ip，也可以是绑定的域名，80端口需要映射到宿主机的80端口，因为之后 github-ci-runner 会从这个端口下载测试源码。

启动成功后，可以通过浏览器访问80端口来使用 gitlab 了。

**创建测试项目**

简单创建一个 `test_ci` 项目，先不要提交到 gitlab 仓库。
包含一个 a.go 文件，文件内容如下:
```go
package main

import fmt 

func main() {
    fmt.Printf("aaa\n")
}
```
可以看到 import 包名没有加双引号，显然编译时就会出错。

**添加 `.gitlab-ci.yml` 文件

配置文件详细内容请参考 [http://doc.gitlab.com/ce/ci/yaml/README.html](http://doc.gitlab.com/ce/ci/yaml/README.html)。
example：
````shell
image: golang:1.5
job1:
    script:
        - go build a.go
        - ./a
```

`image` 表示使用 golang:1.8.3 的 docker 镜像来部署编译和测试代码，我们之前已经下好了。

测试命令有两条，`go build a.go` 编译源码， `./a` 执行编译后的程序。

** 获取Runner registration token**

gitlab 管理员可以进入到特定项目下，更多设置里面有一个 Runners，点进去之后可以看到`Specific Runners`里面有一个 Registration token，这个是就是用于之后创建的 runner 服务与 gitlab 通信的时候认证使用。

**启动Runner**

Runner 官方详细说明文档： [https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/docker.md](https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/docker.md)

Runner其实就是用于编译和管理测试环境的服务，当 gitlab 上的项目有 commit 或 merge 的时候，Runner 可以 hook 到相关信息，然后从 gitlab 上拉取代码，利用 docker 创建一个新的测试环境，之后执行 .gitlab-ci.yml 文件中预先配置好的命令。

```shell
docker run -d --name gitlab-runner --restart always \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -v /srv/gitlab-runner/config:/etc/gitlab-runner \
      gitlab/gitlab-runner:latest
```

**关联 gitlab**

启动成功后的 Runner 需要在 gitlab 上注册，通过在 Runner 上执行注册命令，会调用 gitlab 的相关接口注册。

```shell
docker exec -it gitlab-runner gitlab-runner register

//输入之前的URL
Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci):
https://xxxx.com/ci
 
//输入token
Please enter the gitlab-ci token for this runner:
&lt;CI runner token from Project &gt; Settings &gt; Runner&gt;
 
//描述，这个随意了，一般用默认的就好
Please enter the gitlab-ci description for this runner:
[Your-Mac\'s-Name.local]:
 
//runner的tag，这个是用于执行脚本时指定runner用的，所以最好起一个比较容易区分的
Please enter the gitlab-ci tags for this runner (comma separated):
test_machine
Registering runner... succeeded                     runner=724a60b5
 
//runner的执行器，因为Xcode项目需要用xcodebuild来执行，所以选shell
Please enter the executor: virtualbox, ssh, shell, parallels, docker, docker-ssh:
shell
 
Runner registered successfully. Feel free to start it, but if it's running 
already the config should be automatically reloaded!
```

**如果要使用shell的话**

```shell
# For Debian/Ubuntu
sudo apt-get install gitlab-ci-multi-runner

# For CentOS
sudo yum install gitlab-ci-multi-runner
```
注册:
```shell
$ sudo gitlab-ci-multi-runner register
```

**测试**

接着提交我们之前创建的两个文件，a.go 和 .gitlab-ci.yml。
访问 gitlab 查看 build 的结果。

可以看到提交记录右边有一个红叉，表示测试未通过，点击红叉，可以看到测试的摘要信息。
继续点红色的 failed 按钮就可以看到详细的测试信息。

### 注意事项

1. Docker安装在Linux系上对内核有要求。
2. Docker安装之后要注意查看docker是否正常启动。

### 参考资料

1. [gitlab-ci-quick-start](https://docs.gitlab.com/ce/ci/quick_start/README.html)

----

**茶歇驿站**

一个让你可以在茶歇之余，停下来看一看，里面的内容或许对你有一些帮助。

这里的内容主要是团队管理，个人管理，后台技术相关，其他个人杂想。

![茶歇驿站二维码](http://ww4.sinaimg.cn/large/824dcde4gw1f358o5j022j20by0bywf8.jpg)

当然，你觉得对你有帮助，也可以给我打赏。
![打赏](http://wx4.sinaimg.cn/large/824dcde4gy1fet6crbuxbj20yi1auaej.jpg)